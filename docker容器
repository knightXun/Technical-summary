
Docker容器


容器技术已经成为应用程序封装和交付的核心技术
3大内核技术核心:
Cgroups(Control Groups)-资源管理; 
NameSpace-进程隔离; 
SELinux安全
启动一个容器相当于启动一个进程,Docker不是虚拟化;Docker没有操作系统,只开一个进程;
优点:轻量级,不占内存
缺点:隔离性没有虚拟化强;共用Linux内核,安全性有先天缺陷;SELinux难以驾驭;不易监控和排错

安装Docker
环境要求: 至少64位操作系统;RHEL7版本;关闭防火墙(不是必须)

准备两台虚拟机，IP为192.168.1.31和192.168.1.32

步骤一：配置yum源
1）配置IP（虚拟机配置静态ip）docker1和docker2主机同样操作
[root@localhost ~]# echo docker1 > /etc/hostname 
[root@localhost ~]# hostname docker1
[root@localhost ~]# echo docker2 > /etc/hostname 
[root@localhost ~]# hostname docker2
[root@docker1 ~]# vim /etc/sysconfig/network-scripts/ifcfg-eth0
# Generated by dracut initrd
DEVICE="eth0"
ONBOOT="yes"
IPV6INIT="no"
IPV4_FAILURE_FATAL="no"
NM_CONTROLLED="no"
TYPE="Ethernet"
BOOTPROTO="static"
IPADDR="192.168.1.31"
PREFIX=24
GATEWAY=192.168.1.254
[root@docker1 ~]# systemctl restart network

2）配置yum客户端，配置之前openstack的扩展源(RHEL7-extras.iso)即可（docker1和docker2主机同样操作）
[root@docker1 ]# vim /etc/yum.repos.d/rhel.repo
...
[local_extras]
name=CentOS-$releasever - Extras
baseurl="ftp://192.168.1.254/extras"
enabled=1
gpgcheck=0
[root@docker2 ]# vim /etc/yum.repos.d/rhel.repo
...
[local_extras]
name=CentOS-$releasever - Extras
baseurl="ftp://192.168.1.254/extras"
enabled=1
gpgcheck=0

4）安装docker（docker1和docker2主机同样操作）
yum -y install docker
systemctl restart docker
systemctl enable docker
ifconfig     //有docker0说明环境部署完成
docker version        //查看版本

Docter镜像
Docter中容器是基于镜像启动的
镜像采用分层设计
使用快照的cow技术,确保底层数据不丢失

docker hub镜像仓库
https://hub.docker.com
官方提供的公共镜像的仓库(Registry)

docker search busybox
INDEX(名称标签)        NAME (镜像名字)                DESCRIPTION          STARS    [OFFICIAL](官方)   AUTOMATED
[docker.io] [docker.io/busybox(镜像名字)] [Busybox base image.] [1649]     [OK](ok字样官方提供)       

man docker-search 查看man帮助
Docter search:    搜索镜像
Docter pull 镜像:   下载 
Docter push 镜像:   上传

导出,备份: 格式 docker save 名称家标签:默认标签 -o[output] 文件名 
             docker save docker.io/busybox:latest -o ff.tar
导入,恢复: 格式  docker load -i  tar包名                        
              docker load -i ff.tar 

装4个包 centos.tar; redis.tar;  ubuntu.tar ;nginx.tar   

容器的命令和真机的命令是隔离的
启动centos镜像生成一个容器: docker run -it docker.io/centos:latest /bin/bash 
                        docker run -it  类似于 virsh define satrt console .
然后另开一个终端查看容器信息: docker ps 类似于= virsh list

redhat   debian
rpm      dpkg
yum      apt.get

格式 : docker 选项  镜像名称 
镜像命令:          
docker images   查看镜像列表         
docker history  查看镜像制作历史
docker inspect  查看镜像底层信息
docker pull     下载镜像
docker push     上传镜像                docker pull docker.io/busybox
docker inspect  查看容器底层信息
docker rmi      删除本地镜像
docker save     镜像另存为tar包       docker save docker.io/busybox:latest -o ff.tar
docker load     使用tar包导入镜像     docker load -i ff.tar
docker search   搜索镜像
docker tag      修改镜像名称和标签     docker tag docker.io/busybox:latest ooxx:latest


容器常用命令
docker run                 运行容器
docke  ps                  查看正在运行的容器
docker stop                关闭容器
docker satrt               启动容器
docker restart             重启容器
docker inspect             查看容器底层信息
docker top                 查看容器进程列表            
docker stop/start/rm $(docker ps -aq) 删除所有关闭的容器
docker rmi                 删除镜像

pstree -p 0                查看上帝进程
docker  attach             进入容器,exit会导致容器关闭      退出办法:ctrl + p--> q 
docker  exec               进入容器,退出时不会关闭容器    docker exec -it 76 /bin/bash
docker  dommit             将新容器生成新镜像      docker commit 6d78ahhjah 容器名称:标签 
docker  top + 容器id        看指定容器进程
Docker  build -t 镜像名称 Dockerfile所在目录

自定义镜像与仓库

Dockerfile语法格式：
– FROM:                   基础镜像
– MAINTAINER:             镜像创建者信息(说明)
– EXPOSE:                 开放的端口
– ENV:                    设置环境变量
– ADD:                    复制文件到镜像
– RUN:                    制作镜像时执行的命令,可以有多个
– WORKDIR: 类似于cd        定义容器默认工作目录                  
– CMD:                    容器启动时执行的命令,仅可以有一条CMD




***************************************************************************

Dockerfile工作流程
mkdir 目录;cd 目录
vim Dockerfile
Docker build -t 镜像名称 Dockerfile所在目录

例子:用Dockerfile文件创建一个新的镜像文件
mkdir abc                 新建目录
cd abc                    进入目录
touch Dockerfile          Dockerfile文件第一个字母要大写
cp /etc/yum.repos.d/local.repo  ./    cp仓库

vim Dockerfile                           
 FROM docker.io/centos:latest     
 RUN  rm -f /etc/yum.repos.d/*.repo 
 ADD  rr.repo /etc/yum.repos.d/local.repo          
 RUN yum -y install net-tools vim iproute psmisc  bash-completion 装包

docker build -t 镜像名:标签 .
docker build -t test:latest . 生成一个叫test:latest的镜像

**********************************************************************************



vim /usr/lib/systemd/system/httpd.service             查看服务启动命令
ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND       10行


创建一个httpd的镜像


FROM myos:latest                                        
RUN yum -y install httpd
WORKDIR /var/www/html
ADD index.html  /var/www/html/index.html  
ENV hostname="webserver"    
EXPOSE 80                                               设置开放端口号
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]                 启动httpd服务
MAINTAINER  lsy_tom redhat@163.com                       

vim index.html
hello nsd1904

docker build -t myos1:httpd .



**********************************************************************************************************

自定义私有仓库

装包:                                   yum -y install docker-distribution.x86_64 
设置开机自启:                            systemctl start docker-distribution.service
                               	       systemctl enable docker-distribution.service
开启5000端口

访问:                                   curl 192.168.1.31:5000/v2/
查看仓库内容:                            curl 192.168.1.31:5000/v2/_catalog
客户端配置
13行:允许非加密方式访问仓库                ADD_REGISTRY='--add-registry 192.168.1.31:5000'
24行:指定docker仓库地址                  INSECURE_REGISTRY='--insecure-registry 192.168.1.31:5000'                             
重启服务:                               systemctl restart  docker                                
下载官方镜像:                           docker pull busybox:latest

打标签:docker tag   旧镜像  新镜像       docker tag docker.io/myos:http 192.168.1.31:5000/ docker.io/myos:http
上传:  docker push  新镜像              docker push  192.168.1.31:5000/docker.io/myos:http
查看里面有什么镜像:                      curl  http://192.168.1.31:5000/v2/_catalog  
查看里面的镜像标签:                      curl  http://docker1:5000/v2/仓库名称/tags/list  装json插件,更好看

************************************************************************************************
卷的概念
docker容器不保存任何数据,就是一进程
重要数据使用外部卷存储(数据持久化)
容器可以挂载真实目录或共享存储为卷

docker run -itd -v 宿主机目录:容器目录 myos:latest


NFS共享存储
服务器创建NFS共享存储，共享目录为/content，权限为rw
客户端挂载共享，并将共享目录映射到容器中

步骤一：配置NFS服务器:            yum -y install nfs-utils      
                               mkdir /目录A
                               vim /etc/exports
root做出的修改普通用户也能访问     /目录A     *(rw，no_root_squash)  
			      systemctl restart nfs-server.service
		              systemctl restart nfs-secure.service
		              chmod 777 /目录A
		              echo 11 > /目录A/index.html

步骤二：配置客户端:                  yum -y install nfs-utils
                             systemctl restart nfs-server.service
                              docker run -itd -p 80:80 myos:httpd
                              showmount -e 服务器ip
                              mkdir /目录B
挂载映射:                              mount -t nfs(文件系统格式) 服务器ip:/目录A /目录B

外部也能访问容器做的web服务器  docker run  -d -p 80:80 -v /目录B:/var/www/html -it http服务镜像




新建docker1网络模型docker:  network   create  [--subnet=10.10.10.0/24]  docker1
[--subnet=10.10.10.0/24] 可以不加
使用自定义网桥（docker1）启动容器:docker  run  --network=docker1   -itd   docker.io/myos



将容器做成客户可以访问的web服务器:docker run -itd -p 80:80 myos:httpd
                             docker run -itd -p 80:80 docker.io/nginx:latest
			    


kubernetes(k8s)

# 什么是k8s

- **Kubernetes**的名字来自希腊语，意思是“舵手” 或 “领航员”。K8s是将8个字母“ubernete”替换为“8”的缩写。
- K8S的创造者，是众人皆知的行业巨头——**Google**。
- 然而K8S并不是一件全新的发明。它的前身，是Google自己捣鼓了十多年的**Borg系统**。
- K8S是2014年6月由Google公司正式公布出来并宣布开源的。

# 为什么要使用k8s

- 就在Docker容器技术被炒得热火朝天之时，大家发现，如果想要将Docker应用于具体的业务实现，是存在困难的——编排、管理和调度等各个方面，都不容易。于是，人们迫切需要一套管理系统，对Docker及容器进行更高级更灵活的管理，就在这个时候，K8S出现了
- Kubernetes是Google 2014年创建管理的，是Google 10多年大规模容器管理技术Borg的开源版本。
- K8s 是容器集群管理系统，是一个开源的平台，可以实现容器集群的自动化部署、自动扩缩容、维护等功能

# 什么时候用

- 快速部署应用
- 快速扩展应用
- 无缝对接新的应用功能
- 节省资源，优化硬件资源的使用

# 在那用

- **可移植**: 支持公有云，私有云，混合云，多重云（multi-cloud）
- **可扩展**: 模块化, 插件化, 可挂载, 可组合
- **自动化**: 自动部署，自动重启，自动复制，自动伸缩/扩展

# 怎么用

- **Build, Ship and Run （创建，发送和运行）**
- **Build once，Run anywhere（搭建一次，到处能用）**
- Docker技术的三大核心概念，分别是：

1. 镜像（Image）
2. 容器（Container）
3. 仓库（Repository）

## k8s 架构

一个K8S系统，通常称为一个**K8S集群（Cluster）**

这个集群主要包括两个部分：

- **一个Master节点（主节点）**

- Master节点包括API Server、Scheduler、Controller manager、etcd。

  ​    API Server是整个系统的对外接口，供客户端和其它组件调用，相当于“营业厅”。

  ​    Scheduler负责对集群内部的资源进行调度，相当于“调度室”。

  ​    Controller manager负责管理控制器，相当于“大总管”。


- **一群Node节点（计算节点）**

- Node节点包括**Docker、kubelet、kube-proxy、Fluentd、kube-dns**（可选），还有就是**Pod**。

  ​    **Pod**是Kubernetes最基本的操作单元。

  ​    一个Pod代表着集群中运行的一个进程，它内部封装了一个或多个紧密相关的容器。(docker ps 可以看见,又像一个容器)

  ​    除了Pod之外，K8S还有一个**Service**，一个Service可以看作一组提供相同服务的Pod的对外访问接口

  ​    Docker，不用说了，创建容器的。

  ​    Kubelet，主要负责监视指派到它所在Node上的Pod，包括创建、修改、监控、删除等。

  ​    Kube-proxy，主要负责为Pod对象提供代理。

  ​    Fluentd，主要负责日志收集、存储与查询。(网络)

			    
	安装配置

1 设置 ip 和主机名
  /etc/hosts

2 开启路由转发
vim /etc/sysctl.conf
追加 net.ipv4.ip_forward=1
sysctl -p                                                            立即生效
3 配置 yum 源
[student@room9pc01] cd /linux-soft/04/openstack/RHEL7-extras.iso     yum源
                    mount RHEL7-extras.iso /var/ftp/extras/          挂载    
[root@master ~]# vim /etc/yum.repos.d/local.repo 

			[local_examl]
			name=CentOS-$releasever - examl
			baseurl="ftp://192.168.1.254/extras"
			enabled=1
			gpgcheck=0        
           
4 配置私有仓库 registry [master]
      yum install docker-distribution
  管理镜像使用 docker
      yum install docker
      /etc/sysconfig/docker
  上传镜像
      centos.tar
      kubernetes-dashboard.tar
      pod-infrastructure.tar
  验证
      curl http://192.168.1.100:5000/v2/_catalog

5 配置 kubernets - master
   package(包名):
     etcd
     kubernetes-master
     kubernetes-client
   service(服务名):
     kube-apiserver
     kube-controller-manager
     kube-scheduler
     etcd
   conf:
     /etc/etcd/etcd.conf 
        6: ETCD_LISTEN_CLIENT_URLS="http://0.0.0.0:2379"             搭集群需要改,监听所有网卡
       22: KUBE_MASTER="--master=http://192.168.1.10:8080"           master的IP地址
 
     /etc/kubernetes/config
       22: KUBE_MASTER="--master=http://192.168.1.10:8080"           单机就写master的IP地址
     /etc/kubernetes/apiserver
        8: KUBE_API_ADDRESS="--insecure-bind-address=0.0.0.0"
       17: KUBE_ETCD_SERVERS="--etcd-servers=http://192.168.1.100:2379"  master的ip
       23: 删除 ServiceAccount (参数令牌,安全,相当于"密钥对")
     /etc/kubernetes/controller-manager
     /etc/kubernetes/scheduler
    验证
     kubectl get cs
     kubectl get csr
     kubectl get node

6 配置 kubernets - minion
  package:
     kubernetes-node 
     docker 
  service:
     kubelet
     kube-proxy
     docker
  conf:
     /etc/sysconfig/docker
        4: 添加参数 --insecure-registry=192.168.1.100:5000 --add-registry 192.168.1.100:5000
     /etc/kubernetes/config
       22: KUBE_MASTER="--master=http://192.168.1.100:8080"
     /etc/kubernetes/kubelet
        5: KUBELET_ADDRESS="--address=0.0.0.0"
       11: KUBELET_HOSTNAME="--hostname-override=本机名称"
       14: 添加 --kubeconfig=/etc/kubernetes/kubelet.kubeconfig 
                --pod-infra-container-image=pod-infrastructure:latest
     /etc/kubernetes/kubelet.kubeconfig
apiVersion: v1
kind: Config
clusters:
  - cluster:
      server: http://192.168.1.100:8080                ###Master的IP，即自身IP
    name: local
contexts:
  - context:
      cluster: local
    name: local
current-context: local


7 网络
   master:
     /etc/etcd/etcd.conf
     ETCD_LISTEN_CLIENT_URLS="http://0.0.0.0:2379"

     etcdctl mk /atomic.io/network/config '{"Network": "10.254.0.0/16", "Backend": {"Type": "vxlan"}}'

   minion:
     package: flannel
     /etc/sysconfig/flanneld
     FLANNEL_ETCD_ENDPOINTS="http://192.168.1.100:2379"
  
     systemctl restart flanneld docker

8 创建容器，测试
  kubectl create -f baseos.yaml
  测试
     kubectl get pod -o wide
     kubectl exec -it test-os-3826630470-jc5j4 -- /bin/bash
  
  kubectl create -f kube-dashboard.yaml		    
			    
			    
			    
	
